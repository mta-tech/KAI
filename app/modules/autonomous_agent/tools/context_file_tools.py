"""File-based context tools for the autonomous agent.

These tools let the agent read pre-synced Markdown context files that were
written by ``ContextSyncService``.  They are intentionally low-tech: no
Typesense, no network, just filesystem reads.

Directory structure expected::

    {context_dir}/{db_alias}/tables/{table_name}/columns.md
    {context_dir}/{db_alias}/tables/{table_name}/preview.md
    {context_dir}/{db_alias}/glossary/{term_key}.md
    {context_dir}/{db_alias}/instructions/{rule_key}.md
"""

from __future__ import annotations

import json
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

_MAX_MATCHES = 20
_CONTEXT_LINES = 3  # Lines of surrounding context per match


def create_search_context_files_tool(context_dir: str, db_alias: str):
    """Create a tool that searches pre-synced context Markdown files.

    Args:
        context_dir: Base directory containing synced context files.
        db_alias: Database alias (sub-directory name under context_dir).

    Returns:
        A callable suitable for use as an agent tool.
    """
    base_path = Path(context_dir) / db_alias

    def search_context_files(
        query: str,
        file_type: str | None = None,
    ) -> str:
        """Search pre-synced context Markdown files for a keyword or phrase.

        Performs a case-insensitive text search across schema, glossary, and
        instruction files that were previously generated by ``kai context sync``.

        Use this tool when you want to quickly find relevant domain knowledge
        without hitting the database.

        Args:
            query: Search term or phrase (case-insensitive).
            file_type: Optional filter â€” one of "tables", "glossary",
                "instructions".  Omit to search all types.

        Returns:
            JSON with matching file paths, line numbers, and text excerpts.
        """
        if not base_path.exists():
            return json.dumps({
                "success": True,
                "message": f"No context files found at {base_path}. "
                           "Run 'kai context sync' to generate them.",
                "matches": [],
            })

        # Determine which subdirectory to search
        if file_type in ("tables", "glossary", "instructions"):
            search_root = base_path / file_type
        else:
            search_root = base_path

        matches: list[dict] = []
        query_lower = query.lower()

        for md_file in sorted(search_root.rglob("*.md")):
            if len(matches) >= _MAX_MATCHES:
                break
            try:
                lines = md_file.read_text(encoding="utf-8").splitlines()
            except OSError as exc:
                logger.warning(f"Could not read {md_file}: {exc}")
                continue

            for i, line in enumerate(lines):
                if query_lower in line.lower():
                    start = max(0, i - _CONTEXT_LINES)
                    end = min(len(lines), i + _CONTEXT_LINES + 1)
                    matches.append({
                        "file": str(md_file.relative_to(base_path)),
                        "line": i + 1,
                        "excerpt": "\n".join(lines[start:end]),
                    })
                    if len(matches) >= _MAX_MATCHES:
                        break

        return json.dumps({
            "success": True,
            "query": query,
            "total_matches": len(matches),
            "matches": matches,
        })

    search_context_files.__name__ = "search_context_files"
    return search_context_files


def create_read_context_file_tool(context_dir: str, db_alias: str):
    """Create a tool that reads a single pre-synced context Markdown file.

    Args:
        context_dir: Base directory containing synced context files.
        db_alias: Database alias (sub-directory name under context_dir).

    Returns:
        A callable suitable for use as an agent tool.
    """
    base_path = Path(context_dir) / db_alias

    def read_context_file(path: str) -> str:
        """Read a pre-synced context Markdown file by relative path.

        Use this after ``search_context_files`` to read the full content of a
        specific file.  The ``path`` argument should be the relative path
        returned in the search results (e.g. ``tables/orders/columns.md``).

        Args:
            path: Relative path inside the context directory for this database.
                  Example: ``"tables/orders/columns.md"``

        Returns:
            The file content as plain text, or an error JSON if not found.
        """
        # Security: resolve and verify the path stays within base_path
        try:
            target = (base_path / path).resolve()
            base_resolved = base_path.resolve()
            if not str(target).startswith(str(base_resolved) + "/") and target != base_resolved:
                return json.dumps({
                    "success": False,
                    "error": "Path traversal attempt detected.",
                })
        except Exception as exc:
            return json.dumps({"success": False, "error": str(exc)})

        if not target.exists():
            return json.dumps({
                "success": False,
                "error": f"File not found: {path}",
            })

        try:
            content = target.read_text(encoding="utf-8")
            return content
        except OSError as exc:
            return json.dumps({"success": False, "error": str(exc)})

    read_context_file.__name__ = "read_context_file"
    return read_context_file
